<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.353">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Federico Pavone">
<meta name="dcterms.date" content="2023-10-16">

<title>Meeting KAUST</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="meeting_files/libs/clipboard/clipboard.min.js"></script>
<script src="meeting_files/libs/quarto-html/quarto.js"></script>
<script src="meeting_files/libs/quarto-html/popper.min.js"></script>
<script src="meeting_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="meeting_files/libs/quarto-html/anchor.min.js"></script>
<link href="meeting_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="meeting_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="meeting_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="meeting_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="meeting_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#euclidean-graphs" id="toc-euclidean-graphs" class="nav-link active" data-scroll-target="#euclidean-graphs">About Euclidean graphs</a></li>
  <li><a href="#sensitivity" id="toc-sensitivity" class="nav-link" data-scroll-target="#sensitivity">Sensitivity analysis</a>
  <ul class="collapse">
  <li><a href="#model-sensitivity" id="toc-model-sensitivity" class="nav-link" data-scroll-target="#model-sensitivity">Model-related sensitivity</a>
  <ul class="collapse">
  <li><a href="#the-whittle-matern-field-model-bolin-et-al.-2023" id="toc-the-whittle-matern-field-model-bolin-et-al.-2023" class="nav-link" data-scroll-target="#the-whittle-matern-field-model-bolin-et-al.-2023">The Whittle-Matern field model (Bolin et al., 2023)</a></li>
  <li><a href="#the-isotropic-exponential-covariance-model-anderes-et-al-2020" id="toc-the-isotropic-exponential-covariance-model-anderes-et-al-2020" class="nav-link" data-scroll-target="#the-isotropic-exponential-covariance-model-anderes-et-al-2020">The isotropic (exponential) covariance model (Anderes et al, 2020)</a></li>
  <li><a href="#simulations" id="toc-simulations" class="nav-link" data-scroll-target="#simulations">Simulations</a></li>
  </ul></li>
  <li><a href="#signal-based-sensitivity" id="toc-signal-based-sensitivity" class="nav-link" data-scroll-target="#signal-based-sensitivity">Signal-based sensitivity</a>
  <ul class="collapse">
  <li><a href="#simulations-1" id="toc-simulations-1" class="nav-link" data-scroll-target="#simulations-1">Simulations</a></li>
  </ul></li>
  <li><a href="#definitions" id="toc-definitions" class="nav-link" data-scroll-target="#definitions">Definitions</a></li>
  </ul></li>
  <li><a href="#what-is-new" id="toc-what-is-new" class="nav-link" data-scroll-target="#what-is-new">What is new</a>
  <ul class="collapse">
  <li><a href="#sample-based-sensitivity" id="toc-sample-based-sensitivity" class="nav-link" data-scroll-target="#sample-based-sensitivity">Sample-based sensitivity</a></li>
  <li><a href="#distributional-properties-of-local-influence-for-quadratic-forms" id="toc-distributional-properties-of-local-influence-for-quadratic-forms" class="nav-link" data-scroll-target="#distributional-properties-of-local-influence-for-quadratic-forms">Distributional properties of local influence for quadratic forms</a>
  <ul class="collapse">
  <li><a href="#isotropic-model-assumption-or-data-generation" id="toc-isotropic-model-assumption-or-data-generation" class="nav-link" data-scroll-target="#isotropic-model-assumption-or-data-generation">Isotropic model assumption (or data generation)</a></li>
  </ul></li>
  <li><a href="#model-based-sensitivity" id="toc-model-based-sensitivity" class="nav-link" data-scroll-target="#model-based-sensitivity">Model-based sensitivity</a></li>
  </ul></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Meeting KAUST</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Federico Pavone </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">October 16, 2023</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<section id="euclidean-graphs" class="level1">
<h1>About Euclidean graphs</h1>
<p>The definition of Euclidean graphs given by Anderes et al.&nbsp;(2020) is the following:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Screenshot%202023-10-01%20at%2012.19.13.png" class="img-fluid figure-img" width="544"></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Screenshot%202023-10-01%20at%2012.19.17.png" width="540" height="91" class="figure-img"></p>
</figure>
</div>
<p>The only condition is given by point c), the <em>distance consistency</em>. This condition resembles a triangular inequality (for this reason Euclidean?). It seems that a necessary (and maybe sufficient) condition to satisfy this property is the following: “<em>if two vertices are connected by an edge, this must be the shortest path (under any chosen metric)</em>”.</p>
<p>Therefore, it looks like we can transform a non-Euclidean graph by breaking any edge connecting two nodes, which does not represented the shortest path between the two, adding a new node and dividing the edge in two “sub”-edges.</p>
<p>For instance, in the cycle example the distance consistency implies that:</p>
<p><span class="math display">\[
\overline{e}_0 - \underline{e}_0 \leq \sum_{\mathcal{E}\ni e\neq e_0} (\overline{e}-\underline{e}),
\]</span></p>
<p>which means that any edge cannot span more than half of the circumference. But if any edge violates this requirement, one can just break down the edge by adding a new node and having the condition satisfied.</p>
<ol type="1">
<li>Is there any fallacy in this reasoning?</li>
<li>If not, what then is the “true” meaning (and the effect) of having a 2-degree node in the network? We can add and remove them, and obtain Euclidean and non-Euclidean graphs.</li>
</ol>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Screenshot%202023-10-01%20at%2017.02.38.png" class="img-fluid figure-img" width="542"></p>
<figcaption class="figure-caption">Image from Anderes et al.&nbsp;(2020)</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Screenshot%202023-10-01%20at%2016.55.37.png" class="img-fluid figure-img" width="533"></p>
<figcaption class="figure-caption">Image from Porcu et al.&nbsp;(2023)</figcaption>
</figure>
</div>
</section>
<section id="sensitivity" class="level1">
<h1>Sensitivity analysis</h1>
<p>We can perhaps reason about two directions of sensitivity analysis: <em>model-related sensitivity</em> or <em>signal-related sensitivity</em>.</p>
<p>We can refer to <em>model-related sensitivity</em> as the one regarding the robustness of a given model. For instance: parameter estimates, prediction accuracy, uncertainty calibration, etc..</p>
<p>Meanwhile, we can refer to <em>signal-related sensitivity</em> as the robustness of empirical-based estimates regarding functions defined on graphs, such as empirical variogram in spatial contexts.</p>
<p>Possibly for both types of sensitivities, we can consider two perturbation scenarios:</p>
<ol type="1">
<li>Perturbation of the observed values in some point, given the network. Ideally, we would like to see and learn patterns for the robustness of the model estimates against some topological features of the network</li>
<li>Perturbation of the network, given the observed values. It is perhaps meaningful if we observe the process only on the verteces and, e.g., we consider removing or adding edges.</li>
</ol>
<p>For the simulations we rely on the <code>R</code>-package <code>MetricGraph</code>. The package allows us to manipulate networks, simulate data, and estimate some models. In particular, all simulated data comes from the Whittle-Matern process.</p>
<section id="model-sensitivity" class="level2">
<h2 class="anchored" data-anchor-id="model-sensitivity">Model-related sensitivity</h2>
<p>At this stage, the general experiment is given by the following procedure:</p>
<ol type="1">
<li>Define a (Euclidean) metric graph.</li>
<li>Simulate data from the WM model, fixing the hyperparameters. We can consider different data locations (we always include the network verteces).</li>
<li>Consider different level h of perturbations of the data at the verteces.</li>
<li>Fit the <code>WM</code> model and the <code>isoCov</code> model, and look at the parameter estimates.</li>
</ol>
<p><span style="background-color: #FFFF00">TODO</span> In general, we can simulate the data also from the <code>isoCov</code> process by defining the locations, computing the pairwise resistance distances, and sample the associated multivariate Gaussian. This sounds more reasonable as in this way we can fairly compare the estimates to the true parameter values for both processes.</p>
<section id="the-whittle-matern-field-model-bolin-et-al.-2023" class="level3">
<h3 class="anchored" data-anchor-id="the-whittle-matern-field-model-bolin-et-al.-2023">The Whittle-Matern field model (Bolin et al., 2023)</h3>
<p>The <code>WM</code> model is defined through a SPDE on the graph (with proper notions of differential operators and boundary conditions on the graph): <span class="math display">\[
(\kappa^2 - \Delta)^{\alpha/2}\tau u = W,
\]</span> where <span class="math inline">\(W\)</span> is the white noise process. Parameter <span class="math inline">\(\tau^2\)</span> is related to the inverse of the variance, <span class="math inline">\(\kappa\)</span> is related to the length-scale of the model, and <span class="math inline">\(\alpha\)</span> to the smoothness. The above equation relates to the classical Matern covariance as follows: <span class="math display">\[
r(d)=\frac{\Gamma(\nu)}{\tau^2\Gamma(\nu+1/2)\sqrt{4\pi}\kappa^{2\nu}}(\kappa d)^\nu \mathcal{K}_\nu(\kappa d),
\]</span> considering <span class="math inline">\(\alpha = \nu + 1/2\)</span>. The <code>R</code> package has two different parametrizations: <span class="math inline">\((\nu,\sigma,\rho)\)</span> and <span class="math inline">\((\alpha,\tau,\kappa)\)</span>, where <span class="math inline">\(\rho\)</span> is named <em>range</em> and it is the practical correlation range (i.e, correlation less than 0.1 for <span class="math inline">\(d&gt;\rho\)</span>). The relation between the two parametrizations is the following:</p>
<p><span class="math display">\[
\begin{cases}
\alpha = \nu + 1/2 \\
\rho = \sqrt{8\nu}/\kappa \\
\sigma^2 = \frac{\Gamma(\nu)}{\tau^2\Gamma(\nu+1/2)\sqrt{4\pi}\kappa^{2\nu}}
\end{cases}
\]</span></p>
</section>
<section id="the-isotropic-exponential-covariance-model-anderes-et-al-2020" class="level3">
<h3 class="anchored" data-anchor-id="the-isotropic-exponential-covariance-model-anderes-et-al-2020">The isotropic (exponential) covariance model (Anderes et al, 2020)</h3>
<p>The covariance function is the following: <span class="math display">\[
r(d_R) = \tau^2 \text{exp}(- \kappa d_R),
\]</span> where <span class="math inline">\(d_R\)</span> is the <em>resistance metric</em> on the graph. The <code>MetricGraph</code> parameterization is given by <span class="math inline">\((\tau,\kappa)\)</span>, where this time <span class="math inline">\(\tau^2\)</span> is proportional to the marginal variance, rather than the precision (confusing notation).</p>
</section>
<section id="simulations" class="level3">
<h3 class="anchored" data-anchor-id="simulations">Simulations</h3>
<p>We consider the following examples of networks. Networks <code>Complete (all 1)</code>, <code>Star</code>, and <code>Random (all1)</code> have all edges of unitary length (also in order to guarantee distance consistency)</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/graphs.jpg" class="img-fluid figure-img" width="854"></p>
<figcaption class="figure-caption">Networks</figcaption>
</figure>
</div>
<p>The data locations are one for each vertex, plus a number of point proportional to length of the edge (roughly 10 observations for each unit of length).</p>
<p>We simulate data from the <code>WM</code> process with <span class="math inline">\(\alpha = 1\)</span>, <span class="math inline">\(\tau = 1\)</span>, <span class="math inline">\(\kappa = 1\)</span>. We do <code>nsim=20</code> simulations, with fixed locations, and compute the <strong>median estimates</strong> across simulations for the <span class="math inline">\(\tau\)</span> and <span class="math inline">\(\kappa\)</span> parameters for both <code>WM</code> and <code>isoCov</code> models. When fitting <code>WM</code>, we fix <span class="math inline">\(\alpha\)</span> to the true value of 1.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/isocov_wm1.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Fixed locations</figcaption>
</figure>
</div>
<p>Due to the unexpected asymmetry in the complete network, we consider another set of simulations where at each step we resample also the locations.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/isocov_wm1_avgloc.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Averaged locations</figcaption>
</figure>
</div>
</section>
</section>
<section id="signal-based-sensitivity" class="level2">
<h2 class="anchored" data-anchor-id="signal-based-sensitivity">Signal-based sensitivity</h2>
<p>Here we investigate the sensitivity of sample-based estimates of some quantities of interest. An example borrowed from spatial statistics is the variogram <span class="math display">\[
2\gamma(h) = \frac{1}{\mid N_h \mid} \sum_{(i,j)\in N_h} (Z_i - Z_h)^2.
\]</span> As showed in Genton and Ruiz-Gazen (2010), this quantity can be written as a quadratic form <span class="math inline">\(Z^\intercal A Z\)</span> of the data values <span class="math inline">\(Z=(Z_1,\dots,Z_N)^\intercal\)</span>, for a certain symmetric matrix <span class="math inline">\(A\)</span>. It follows that we have analytical expressions for the local and asymptotic influences (Genton and RUiz-Gazen, 2010): <span class="math display">\[
\tau_i(\hat{\theta},Z) = 2a_i^\intercal Z,
\]</span> where <span class="math inline">\(a_i\)</span> is the vector given by the i-th row of <span class="math inline">\(A\)</span>.</p>
<p>In the context of networks, a quantity of interest is the <em>graph Laplacian</em>. There are multiple definitions of graph Laplacian, but the basic one for an undirected graph is given by a <span class="math inline">\(n\times n\)</span> matrix <span class="math inline">\(L\)</span> with entries <span class="math display">\[
L_{ij} = \begin{cases}
d_i  &amp; \text{if} \quad i=j \\
-1  &amp; \text{if} \quad (i,j)\in E \\
0 &amp; \text{otherwise}
\end{cases},
\]</span> where <span class="math inline">\(d_i\)</span> is the degree of the node (number of edges associated to that node). In case of a weigthed graph with weight <span class="math inline">\(w_{ij}\)</span> for the edge <span class="math inline">\((i,j)\in E\)</span>, one generalization is given by: <span class="math display">\[
L_{ij} = \begin{cases}
w_i &amp; \text{if} \quad i=j \\
-w_{ij} &amp; \text{if} \quad (i,j)\in E \\
0 &amp; \text{otherwise}
\end{cases},
\]</span> where <span class="math inline">\(w_i\)</span> is the sum of the weights of the edges connected to node <span class="math inline">\(i\)</span>.</p>
<p>Considering a vertex-valued function <span class="math inline">\(Z:V\rightarrow \mathbb{R}\)</span>, there exists a measure of the weighted-smoothness given by the <em>graph Laplacian quandratic form</em>:</p>
<p><span class="math display">\[
S_2(Z) := \sum_{(i,j)\in E} w_{ij}(Z_j - Z_i)^2 = Z^\intercal L Z.
\]</span> This resembles to some extent the variogram definition. Note that here the squared difference are computed between all connected vertices rather than at a fixed lag <span class="math inline">\(h\)</span>. Moreover, the larger the weight, the more important is the difference. Therefore, in our context we may want to choose: <span class="math display">\[
w_{ij} = 1/d_{\cdot \mathcal{G}}(i,j), \qquad \forall (i,j)\in E,
\]</span> with either the geodesic or resistance distance.</p>
<p>The advantage of <span class="math inline">\(S_2(Z)\)</span> is that it is a quadratic form, and thus we can leverage Genton and Ruiz-Gazen (2010) and directly compute the local influence for each vertex: <span class="math display">\[
\tau_i(S_2,Z) = 2l_i^\intercal Z,
\]</span> with <span class="math inline">\(l_i\)</span> the i-th row of the graph Laplacian <span class="math inline">\(L\)</span>.</p>
<p><span style="background-color: #FFFF00">TODO</span> We can consider extension of this idea to all observations on graph (maybe not trivial), and other version of the Laplacian (normalized, etc..).</p>
<section id="simulations-1" class="level3">
<h3 class="anchored" data-anchor-id="simulations-1">Simulations</h3>
<p>We do the following experiment:</p>
<ol type="1">
<li>We sample a network with a given node distribution.</li>
<li>We simulate on the vertexes from <code>WM</code> with <span class="math inline">\(\alpha=\kappa=\tau=1\)</span>.</li>
<li>We compute the local influence of each node for a total of <code>nsim=100</code> simulations.</li>
</ol>
<p>In particular, we sample a network with a power-law distribution for the node degree. That is, the degree distribution is <span class="math inline">\(\propto 1/x^a\)</span>. We set <span class="math inline">\(a=1\)</span>. We normalize all the edge lengths to be equal to 1, in order to isolate the effect of the node degree on the result.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/graph_power1.png" class="img-fluid figure-img" width="329"></p>
<figcaption class="figure-caption">Simulated network with power-law degree distribution</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/locinf.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Boxplot of the node local influences on <span class="math inline">\(S_2(Z)\)</span></figcaption>
</figure>
</div>
<p><span style="background-color: #FFFF00">TODO</span> Consider different topologies and include branch lengths.</p>
</section>
</section>
<section id="definitions" class="level2">
<h2 class="anchored" data-anchor-id="definitions">Definitions</h2>
<ol type="1">
<li>Vertex closeness <span class="math display">\[
c(v) = \frac{1}{\sum_{u\in V}d(u,v)}
\]</span></li>
<li>Vertex betweenness <span class="math display">\[
b(v) = \sum_{s\neq t \neq v \in V}\frac{\sigma(s,t\mid v)}{\sigma(s,t)},
\]</span> where <span class="math inline">\(\sigma(s,t)\)</span> is the total number of shortest paths from <span class="math inline">\(s\)</span> to <span class="math inline">\(t\)</span>, and <span class="math inline">\(\sigma(s,t\mid v)\)</span> is the number of those passing through <span class="math inline">\(v\)</span>.</li>
</ol>
</section>
</section>
<section id="what-is-new" class="level1">
<h1>What is new</h1>
<p>We are working on two fronts: model-based and sample-based sensitivity.</p>
<section id="sample-based-sensitivity" class="level2">
<h2 class="anchored" data-anchor-id="sample-based-sensitivity">Sample-based sensitivity</h2>
<p>We consider different quadratic forms or ratio of quadratic forms:</p>
<ul>
<li><p>Graph Laplacian quandratic form <span class="math display">\[
S_2(Z) := \sum_{(i,j)\in E} w_{ij}(Z_j - Z_i)^2 = Z^\intercal L Z.
\]</span></p></li>
<li><p>Moran’s I, based on the graph adjacency matrix <span class="math display">\[
I = \frac{\sum_{i,j=1}^n w_{ij} (Z_i - \bar{Z})^\intercal(Z_j - \bar{Z})}{\sum_{i=1}^n (Z_i - \bar{Z})^2},
\]</span> where the weights are the entries of the adjacency matrix, i.e.&nbsp;<span class="math inline">\(w_{ij} = a_{ij} = I(e_{ij}\in E)\)</span></p></li>
<li><p>Moran’s I, based on the radius-1 ball in resistance distance. In other words, for each node we consider the radius-1 ball and assign weights <span class="math display">\[
w^1_{ij} = \begin{cases}
1/d_R(v_i,v_j) &amp; \text{if} \quad d_R(v_i,v_j)&lt;1 \\
0 &amp; \text{otherwise}
\end{cases}
\]</span> Given <span class="math inline">\(w_{ij}\)</span>, we consider the classical Moran’s I <span class="math display">\[
I^1_R = \frac{\sum_{i,j=1}^n w^1_{ij} (Z_i - \bar{Z})^\intercal(Z_j - \bar{Z})}{\sum_{i=1}^n (Z_i - \bar{Z})^2},
\]</span></p></li>
<li><p>Raylegh quotient of the graph Laplacian <span class="math display">\[
Q =\frac{Z^\intercal L Z}{Z^\intercal Z}
\]</span></p></li>
</ul>
<p>We sample a network approximately with the power-law degree distribution, that is: <span class="math display">\[
P(\text{node has degree d}) = d^{-\beta}
\]</span></p>
<div class="panel-grid layout-sidebar ms-md-0 layout-sidebar-left">
<div class="cell panel-sidebar card bg-light p-2 g-col-24 g-col-lg-7">
<div class="cell-output-display">
<h2 class="anchored">Visualization</h2>
</div>
<div class="cell-output-display">
<div class="form-group shiny-input-container">
<label class="control-label" id="seed-label" for="seed">Network-node seed</label>
<input id="seed" type="text" class="shiny-input-text form-control" value="32423">
</div>
</div>
<div class="cell-output-display no-overflow-x">
<div class="form-group shiny-input-container">
<label class="control-label" id="fill-label" for="fill">Coloring attribute</label>
<div>
<select id="fill" class="shiny-input-select"><option value="Degree_res">Degree_res</option>
<option value="Degree" selected="">Degree</option>
<option value="Betweenness">Betweenness</option>
<option value="Closeness">Closeness</option>
<option value="Harmonic">Harmonic</option>
<option value="Authority">Authority</option>
<option value="PageRank">PageRank</option>
<option value="Triangles">Triangles</option>
<option value="Eigen_centrality">Eigen_centrality</option>
<option value="Subgraph_centrality">Subgraph_centrality</option>
<option value="degbet">degbet</option></select>
<script type="application/json" data-for="fill" data-nonempty="">{"plugins":["selectize-plugin-a11y"]}</script>
</div>
</div>
</div>
<div class="cell-output-display no-overflow-x">
<div class="form-group shiny-input-container">
<label class="control-label" id="plot-label" for="plot">What to plot</label>
<div>
<select id="plot" class="shiny-input-select"><option value="Local influence" selected="">Local influence</option>
<option value="Asymptotic influence">Asymptotic influence</option></select>
<script type="application/json" data-for="plot" data-nonempty="">{"plugins":["selectize-plugin-a11y"]}</script>
</div>
</div>
</div>
<div class="cell-output-display">
<h2 class="anchored">Data simulation parameters</h2>
</div>
<div class="cell-output-display no-overflow-x">
<div class="form-group shiny-input-container">
<label class="control-label" id="net_degree-label" for="net_degree">Network degree distribution</label>
<div>
<select id="net_degree" class="shiny-input-select"><option value="constant">constant</option>
<option value="exp">exp</option>
<option value="power 0.5">power 0.5</option>
<option value="power 1" selected="">power 1</option>
<option value="power 2">power 2</option></select>
<script type="application/json" data-for="net_degree" data-nonempty="">{"plugins":["selectize-plugin-a11y"]}</script>
</div>
</div>
</div>
<div class="cell-output-display no-overflow-x">
<div class="form-group shiny-input-container">
<label class="control-label" id="tau-label" for="tau">Tau</label>
<div>
<select id="tau" class="shiny-input-select"><option value="0.5">0.5</option>
<option value="1" selected="">1</option>
<option value="2">2</option></select>
<script type="application/json" data-for="tau" data-nonempty="">{"plugins":["selectize-plugin-a11y"]}</script>
</div>
</div>
</div>
<div class="cell-output-display no-overflow-x">
<div class="form-group shiny-input-container">
<label class="control-label" id="kappa-label" for="kappa">Kappa</label>
<div>
<select id="kappa" class="shiny-input-select"><option value="0.1">0.1</option>
<option value="1" selected="">1</option>
<option value="10">10</option></select>
<script type="application/json" data-for="kappa" data-nonempty="">{"plugins":["selectize-plugin-a11y"]}</script>
</div>
</div>
</div>
<div class="cell-output-display no-overflow-x">
<div class="form-group shiny-input-container">
<label class="control-label" id="alpha-label" for="alpha">Alpha</label>
<div>
<select id="alpha" class="shiny-input-select"><option value="1" selected="">1</option>
<option value="2">2</option></select>
<script type="application/json" data-for="alpha" data-nonempty="">{"plugins":["selectize-plugin-a11y"]}</script>
</div>
</div>
</div>
</div>
<div class="panel-fill panel-grid g-col-24 g-col-lg-17 pt-3 pt-lg-0">
<div class="g-col-24">
<div class="cell panel-fill">
<div class="cell-output-display">
<div class="visNetwork html-widget html-widget-output shiny-report-size html-fill-item-overflow-hidden html-fill-item" id="network" style="width:100%;height:400px;"></div>
</div>
<div class="cell-output-display">
<div class="shiny-plot-output html-fill-item" id="sensitivity" style="width:100%;height:500px;"></div>
</div>
</div>
</div>
</div>
</div>
<p>Observations:</p>
<ul>
<li>Some topological node features partially explain the amount of local influence. For instance, the node degree, the betweenness, and the product of the two (degbet)</li>
<li>However, these explanatory power is still partial</li>
<li>The local influence seems to be “independent” of the the specific quadratic form, at least for some of the nodes. However, all the considered quadratic form are related (the matrix <span class="math inline">\(A\)</span> depends on the topology). This is possibly not a restriction, as typically in applications this is the type of quadratic forms of interest.</li>
</ul>
<p>The quantities <span class="math inline">\(I\)</span>, <span class="math inline">\(I^1_R\)</span>, and <span class="math inline">\(Q\)</span> are ratios of quadratic forms (<span class="math inline">\(\Theta\)</span>), whereas <span class="math inline">\(S_2\)</span> is just a quadratic form (<span class="math inline">\(\theta\)</span>): <span class="math display">\[
\Theta = \frac{Z^\intercal A Z}{Z^\intercal B Z} \qquad \qquad \theta = Z^\intercal A Z.
\]</span> The local influence and the asymptotic influence in both cases are given by <span class="math display">\[
\begin{aligned}
\tau_i &amp;= \frac{2}{Z^\intercal B Z}(a_i - \Theta b_i)^\intercal Z, \\
\nu_i &amp;= \frac{a_{ii}}{b_{ii}},
\end{aligned}
\qquad \qquad
\begin{aligned}
\tau_i &amp;= 2a_i^\intercal Z, \\
\nu_i &amp;= \infty.
\end{aligned}
\]</span> Let us consider the local influence <span class="math inline">\(\tau_i\)</span>. With the previous plots, we consider the distribution of <span class="math inline">\(\tau_i\)</span>, across different realization of <span class="math inline">\(Z\)</span>. We have:</p>
<ul>
<li><span class="math inline">\(\Theta = \Theta(Z,A,B)\)</span>, deterministic function</li>
<li><span class="math inline">\(Z = Z\mid A\)</span>, as typically <span class="math inline">\(A\)</span> represent some topological information (e.g.&nbsp;adjacency matrix, Laplacian)</li>
</ul>
<p>In general, <span class="math display">\[
\tau_i = \tau_i(Z,A,B)
\]</span> and we are interested in <span class="math inline">\(\mathcal{L}(\tau_i\mid A, B)\)</span>. Can we try to compute/learn something about this distribution?</p>
<p>Consider also that we notice similar pattern between the local influence for the quadratic form (<span class="math inline">\(S_2\)</span>) and the ratios of quadratic forms. Therefore, maybe it is easier to study the distribution of: <span class="math display">\[
\tau_i = 2 a_i^\intercal Z.
\]</span></p>
</section>
<section id="distributional-properties-of-local-influence-for-quadratic-forms" class="level2">
<h2 class="anchored" data-anchor-id="distributional-properties-of-local-influence-for-quadratic-forms">Distributional properties of local influence for quadratic forms</h2>
<p>Considering the previous analysis, we are mostly interesting in the marginal variances of the vector <span class="math inline">\(\tau = (\tau_1, \dots, \tau_n)^\intercal\)</span>. If we assume that the data come from a certain Gaussian process, we have <span class="math display">\[
Z \sim \text{N}(0, \Sigma) \qquad \implies \qquad \tau \sim (0, 4\,A\Sigma A^\intercal).
\]</span> Therefore, the vector of marginal variances is given by <span class="math display">\[
\text{var}(\tau) = \text{diag}(4\,A\Sigma A^\intercal) = 4 \,( A\circ(A\Sigma)) 1_n,
\]</span> where the operator <span class="math inline">\(\circ\)</span> represent the Hadamard product, or elementwise product. We can expand the matrix product for the local influence of node <span class="math inline">\(i\)</span>, <span class="math display">\[
\begin{aligned}
\text{var}(\tau_i) &amp;= 4 \sum_{j=1}^n \sum_{k=1}^n A_{ij} A_{ik} \Sigma_{kj} \\
&amp;= 4 \sum_{j=1}^n \sum_{k=1}^n A_{ij} A_{ik} \text{Cov}(Z_j,Z_k).
\end{aligned}
\]</span> Often, the matrix <span class="math inline">\(A\)</span> that define the quadratic form is the adjacency matrix, or the Laplacian matrix of the graph, which has non-zero entries only for <span class="math inline">\(A_{ij}\)</span> such that <span class="math inline">\((i,j)\in E\)</span>. Therefore, the result of the multiplication between <span class="math inline">\(A_{ij}\)</span> and <span class="math inline">\(A_{ik}\)</span> is non-zero only for the couples <span class="math inline">\((j,k)\in N_i\)</span>, where <span class="math inline">\(N_i\)</span> is the set of the neighbour nodes of <span class="math inline">\(i\)</span>. We can rewrite the marginal variance as: <span class="math display">\[
\begin{aligned}
\text{var}(\tau_i) &amp;= 8 \sum_{(i,j)\in N_i} A_{ij} A_{ik} \text{Cov}(Z_j,Z_k).
\end{aligned}
\]</span> Clearly, the value of <span class="math inline">\(\text{Cov}(Z_j,Z_k)\)</span> depends on the data generating process assumptions. However, in general we can believe this to be decreasing with the distance between <span class="math inline">\(Z_j\)</span> and <span class="math inline">\(Z_k\)</span>.</p>
<p>We can leverage the above expression to build a model-free sensitivity score for each node, only based on the topological structure of the network. For example (just a first idea): <span class="math display">\[
\text{score}(i) = 8 \sum_{(i,j)\in N_i} A_{ij} A_{ik} \, \text{exp}(-d(j,k)),
\]</span> where <span class="math inline">\(d(\cdot,\cdot)\)</span> is a distance on the graph (e.g., geodesic or resistance). However, such a score may be reasonable only under isotropic model assumptions.</p>
<section id="isotropic-model-assumption-or-data-generation" class="level3">
<h3 class="anchored">Isotropic model assumption (or data generation)</h3>
<p>Under an isotropic Gaussian process model, we can try to derive further calculations. In particular, we consider the <code>isoCov</code> model, where the covariance function is given by <span class="math display">\[
C(d) = \sigma^2\,\text{exp}(-\kappa d).
\]</span> Let us consider the resistance metric on the graph. If we denote with <span class="math inline">\(\tilde{L}\)</span> the Laplacian matrix considering the graph with weights equal to the inverse of the edge lengths (or distances), we can write the matrix of the pairwise resistance distances as: <span class="math display">\[
R = -2L^+ + \text{diag}(\tilde{L}^+)^\intercal\otimes 1_n + 1_n^\intercal\otimes \text{diag}(\tilde{L}^+),
\]</span> where <span class="math inline">\(\tilde{L}^+\)</span> is the pseud-inverse of <span class="math inline">\(\tilde{L}\)</span>, and <span class="math inline">\(\otimes\)</span> is the Kronecker product. If we consider the resistance distance between <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>, this can be written as: <span class="math display">\[
r_{ij} = -2\tilde{L}^+_{ij} + \tilde{L}^+_{ii} + \tilde{L}^+_{jj}.
\]</span> Plugging-in this expression in the formula of the marginal variance of the local influence of a quadratic form, we obtain: <span class="math display">\[
\begin{aligned}
\text{var}(\tau_i) &amp;= 4 \sum_{j=1}^n \sum_{k=1}^n A_{ij} A_{ik} \text{Cov}(Z_j,Z_k) \\
&amp;= 4 \sum_{j=1}^n \sum_{k=1}^n A_{ij} A_{ik} C(r_{jk}) \\
&amp;= 4 \sum_{j=1}^n \sum_{k=1}^n A_{ij} A_{ik} \tilde{C}(\tilde{L}^+_{jj})\tilde{C}(\tilde{L}^+_{kk})\tilde{C}(-2\tilde{L}^+_{jk}) \\
&amp;= 4 \sum_{j=1}^n \sum_{k=1}^n \left[A_{ij}\tilde{C}(\tilde{L}^+_{jj})\right] \, \left[A_{ik}\tilde{C}(\tilde{L}^+_{kk})\right] \,\tilde{C}(-2\tilde{L}^+_{jk})
\end{aligned},
\]</span> where <span class="math inline">\(\tilde{C}(d) = (\sigma^2)^{1/3}\,\text{exp}(-\kappa d)\)</span>, and the above computations follow from considering that <span class="math inline">\(C(\cdot)\)</span> is applied element-wise and it has an exponential form.</p>
<div class="panel-grid layout-sidebar ms-md-0 layout-sidebar-left">
<div class="cell panel-sidebar card bg-light p-2 g-col-24 g-col-lg-7">
<div class="cell-output-display">
<h2 class="anchored" data-anchor-id="isotropic-model-assumption-or-data-generation">Visualization</h2>
</div>
<div class="cell-output-display">
<div class="form-group shiny-input-container">
<label class="control-label" id="seed_isocov-label" for="seed_isocov">Network-node seed</label>
<input id="seed_isocov" type="text" class="shiny-input-text form-control" value="32423">
</div>
</div>
<div class="cell-output-display no-overflow-x">
<div class="form-group shiny-input-container">
<label class="control-label" id="fill_isocov-label" for="fill_isocov">Coloring attribute</label>
<div>
<select id="fill_isocov" class="shiny-input-select"><option value="Degree_res">Degree_res</option>
<option value="Degree" selected="">Degree</option>
<option value="Betweenness">Betweenness</option>
<option value="Closeness">Closeness</option>
<option value="Harmonic">Harmonic</option>
<option value="Authority">Authority</option>
<option value="PageRank">PageRank</option>
<option value="Triangles">Triangles</option>
<option value="Eigen_centrality">Eigen_centrality</option>
<option value="Subgraph_centrality">Subgraph_centrality</option>
<option value="Sensitivity_score_adj">Sensitivity_score_adj</option>
<option value="degbet">degbet</option></select>
<script type="application/json" data-for="fill_isocov" data-nonempty="">{"plugins":["selectize-plugin-a11y"]}</script>
</div>
</div>
</div>
<div class="cell-output-display no-overflow-x">
<div class="form-group shiny-input-container">
<label class="control-label" id="plot_isocov-label" for="plot_isocov">What to plot</label>
<div>
<select id="plot_isocov" class="shiny-input-select"><option value="Local influence" selected="">Local influence</option>
<option value="Asymptotic influence">Asymptotic influence</option></select>
<script type="application/json" data-for="plot_isocov" data-nonempty="">{"plugins":["selectize-plugin-a11y"]}</script>
</div>
</div>
</div>
<div class="cell-output-display">
<h2 class="anchored">Data simulation parameters</h2>
</div>
<div class="cell-output-display no-overflow-x">
<div class="form-group shiny-input-container">
<label class="control-label" id="net_degree_isocov-label" for="net_degree_isocov">Network degree distribution</label>
<div>
<select id="net_degree_isocov" class="shiny-input-select"><option value="constant">constant</option>
<option value="exp">exp</option>
<option value="power 0.5">power 0.5</option>
<option value="power 1" selected="">power 1</option>
<option value="power 2">power 2</option></select>
<script type="application/json" data-for="net_degree_isocov" data-nonempty="">{"plugins":["selectize-plugin-a11y"]}</script>
</div>
</div>
</div>
<div class="cell-output-display no-overflow-x">
<div class="form-group shiny-input-container">
<label class="control-label" id="sigma_isocov-label" for="sigma_isocov">Sigma</label>
<div>
<select id="sigma_isocov" class="shiny-input-select"><option value="0.5">0.5</option>
<option value="1" selected="">1</option>
<option value="2">2</option></select>
<script type="application/json" data-for="sigma_isocov" data-nonempty="">{"plugins":["selectize-plugin-a11y"]}</script>
</div>
</div>
</div>
<div class="cell-output-display no-overflow-x">
<div class="form-group shiny-input-container">
<label class="control-label" id="kappa_isocov-label" for="kappa_isocov">Kappa</label>
<div>
<select id="kappa_isocov" class="shiny-input-select"><option value="0.1">0.1</option>
<option value="1" selected="">1</option>
<option value="10">10</option></select>
<script type="application/json" data-for="kappa_isocov" data-nonempty="">{"plugins":["selectize-plugin-a11y"]}</script>
</div>
</div>
</div>
</div>
<div class="panel-fill panel-grid g-col-24 g-col-lg-17 pt-3 pt-lg-0">
<div class="g-col-24">
<div class="cell panel-fill">
<div class="cell-output-display">
<div class="visNetwork html-widget html-widget-output shiny-report-size html-fill-item-overflow-hidden html-fill-item" id="network_isocov" style="width:100%;height:400px;"></div>
</div>
<div class="cell-output-display">
<div class="shiny-plot-output html-fill-item" id="sensitivity_isocov" style="width:100%;height:500px;"></div>
</div>
<div class="cell-output-display">
<div class="shiny-plot-output html-fill-item" id="sensitivity_isocov_teo" style="width:100%;height:500px;"></div>
</div>
</div>
</div>
</div>
</div>
<p>From the above results, it seems that also the marginal variance of the local influence for the ratio of quadratic forms is proportional (with a factor of 1000) to the marginal variance of the local influence of the quadratic form at the numerator of the ratio. This is a promising result in a way that a potential unique sensitivity-score can be used for both quadratic forms and ratios.</p>
<p>Next steps:</p>
<ul>
<li>Can we obtain a sensitivity-score only based on the adjacency matrix/Laplacian? Instead of depending on the specific quadratic form</li>
<li>How to generalise on process/data both on vertexes and edges?</li>
<li>Does a potential model-free sensitivity-score for quadratic forms explain also the model-based sensitivity?</li>
</ul>
</section>
</section>
<section id="model-based-sensitivity" class="level2">
<h2 class="anchored" data-anchor-id="model-based-sensitivity">Model-based sensitivity</h2>
<div class="panel-fill panel-grid">
<div class="g-col-24">
<div class="cell panel-fill">
<div class="cell-output-display no-overflow-x">
<div class="form-group shiny-input-container">
<label class="control-label" id="color-label" for="color">Coloring attribute</label>
<div>
<select id="color" class="shiny-input-select"><option value="closeness">closeness</option>
<option value="betweenness">betweenness</option>
<option value="degree">degree</option>
<option value="Harmonic">Harmonic</option>
<option value="Authority">Authority</option>
<option value="PageRank">PageRank</option>
<option value="Triangles">Triangles</option>
<option value="Eigen_centrality">Eigen_centrality</option>
<option value="Subgraph_centrality">Subgraph_centrality</option></select>
<script type="application/json" data-for="color" data-nonempty="">{"plugins":["selectize-plugin-a11y"]}</script>
</div>
</div>
</div>
<div class="cell-output-display no-overflow-x">
<div class="form-group shiny-input-container">
<label class="control-label" id="model-label" for="model">Model (used for fitting)</label>
<div>
<select id="model" class="shiny-input-select"><option value="isoCov" selected="">isoCov</option>
<option value="WM">WM</option></select>
<script type="application/json" data-for="model" data-nonempty="">{"plugins":["selectize-plugin-a11y"]}</script>
</div>
</div>
</div>
<div class="cell-output-display">
<div class="form-group shiny-input-container">
<div class="checkbox">
<label>
<input id="scale" type="checkbox" class="shiny-input-checkbox" checked="checked">
<span>Scaling attribute</span>
</label>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<div class="row">
<div class="shiny-plot-output html-fill-item" id="sensitivity_avgloc" style="width:100%;height:300px;"></div>
</div>
</div>
</div>
<p>
<script type="application/shiny-prerendered" data-context="server-start">
library(here)
library(shiny)
library(tidyverse)
library(visNetwork)
library(scales)
library(igraph)
theme_set(
  theme_light() +
    theme(
      strip.background = element_rect(color = 'gray', fill = 'white'),
      strip.text.x = element_text(color = 'black'),
      strip.text.y = element_text(color = 'black')
    )
)
source(here('sensitivity','helper_fun.R'))

net_degree_options <- c('constant',
                        'exp',
                        'power 0.5',
                        'power 1',
                        'power 2')

res_data <- asym_data <- tibble()
meta_data2 <- tibble()
g_exp_list <- graph_exp_list <- NULL
for(net in net_degree_options){
  load(here('sensitivity','shiny',
            paste('sample_sensitivity_', 
                  str_replace_all(net, pattern = " ", repl = ""), 
                  '.Rdata', sep = '')))
  res_data <- res_data %>%
    bind_rows(data_plot %>%
                mutate(network = net))
  asym_data <- asym_data %>%
    bind_rows(data_asymptotic %>%
                mutate(network = net))
  meta_data2 <- meta_data2 %>%
    bind_rows(meta_data %>%
                mutate(network = net))
  
  g_exp_list <- c(g_exp_list, list(g_exp))
  graph_exp_list <- c(graph_exp_list, list(graph_exp))
}
names(g_exp_list) <- names(graph_exp_list) <- net_degree_options

meta_data2 <- meta_data2 %>%
  mutate(degbet = rank(Degree)*rank(Betweenness),
         .by = "network")

res_data <- full_join(res_data, meta_data2, by = c("node","network"))
asym_data <- asym_data %>%
  mutate_at(vars(node), as.character) %>%
  full_join(meta_data2, by = c("node","network"))


## Isocov
res_data_isocov <- asym_data_isocov <- tibble()
meta_data2_isocov <- tibble()
loc_inf_teo_isocov <- tibble()
g_exp_list_isocov <- graph_exp_list_isocov <- NULL
for(net in net_degree_options){
  load(here('sensitivity','shiny',
            paste('sample_sensitivity_ISOCOV_',
                  str_replace_all(net, pattern = " ", repl = ""),
                  '.Rdata', sep = '')))
  res_data_isocov <- res_data_isocov %>%
    bind_rows(data_plot %>%
                mutate(network = net))
  asym_data_isocov <- asym_data_isocov %>%
    bind_rows(data_asymptotic %>%
                mutate(network = net))
  meta_data2_isocov <- meta_data2_isocov %>%
    bind_rows(meta_data %>%
                mutate(network = net))
  loc_inf_teo_isocov <- loc_inf_teo_isocov %>%
    bind_rows(data_plot_teo %>%
                mutate(network = net))

  g_exp_list_isocov <- c(g_exp_list_isocov, list(g_exp))
  graph_exp_list_isocov <- c(graph_exp_list_isocov, list(graph_exp))
}
names(g_exp_list_isocov) <- names(graph_exp_list_isocov) <- net_degree_options

meta_data2_isocov <- meta_data2_isocov %>%
  mutate(degbet = rank(Degree)*rank(Betweenness),
         .by = "network")

res_data_isocov <- full_join(res_data_isocov, meta_data2_isocov, by = c("node","network"))
asym_data_isocov <- asym_data_isocov %>%
  mutate_at(vars(node), as.character) %>%
  full_join(meta_data2, by = c("node","network"))
loc_inf_teo_isocov <- full_join(loc_inf_teo_isocov, meta_data2_isocov, by = c("node","network"))


### MODEL-BASED SENSITIVITY, AVERAGED LOCATION
load(here('sensitivity','sensitivity_obsperunit_avgloc_061023.Rdata'))

net_powerlaw_all1 <- graph_from_data_frame(d = tibble(source = powerlaw_graph_all1$E[,1],
                                                      target = powerlaw_graph_all1$E[,2],
                                                      weight = powerlaw_graph_all1$edge_lengths),
                                           vertices = 1:nrow(powerlaw_graph_all1$V),
                                           directed = FALSE)
powerlaw_all1_meta <- tibble(node = 1:tot_nodes,
                             closeness = closeness(net_powerlaw_all1),
                             betweenness = betweenness(net_powerlaw_all1),
                             degree = degree(net_powerlaw_all1))

results %>%
  map_dfr(.f = as_tibble,
          .id = 'graph') %>%
  pivot_longer(-c('graph','node','iter','h')) %>%
  mutate(model = str_extract(name,'^[:alpha:]*[:digit:]?'),
         parameter = str_extract(name,'[:alpha:]*$')) %>%
  select(-name) -> res_avgloc_data

scale_score <- function(x, ...)
{
  res <- (x - median(x))/diff(range(x))
  print(...)
  return(res)
}

scale_score <- \(x)((x - median(x))/diff(range(x)))

comp_meta %>%
  mutate(graph = "Complete_all1",
         Harmonic = harmonic_centrality(net_comp_all1),
         Authority = authority_score(net_comp_all1)$vector,
         PageRank = page_rank(net_comp_all1, directed = FALSE)$vector,
         Triangles = sapply(1:n_nodes, FUN = count_triangles, graph = net_comp_all1),
         Eigen_centrality = eigen_centrality(net_comp_all1, directed = FALSE)$vector,
         Subgraph_centrality = subgraph_centrality(net_comp_all1, diag = FALSE)) %>%
  bind_rows(star_meta %>%
              mutate(graph = "Star",
                     Harmonic = harmonic_centrality(net_star),
                     Authority = authority_score(net_star)$vector,
                     PageRank = page_rank(net_star, directed = FALSE)$vector,
                     Triangles = sapply(1:n_nodes, FUN = count_triangles, graph = net_star),
                     Eigen_centrality = eigen_centrality(net_star, directed = FALSE)$vector,
                     Subgraph_centrality = subgraph_centrality(net_star, diag = FALSE))) %>%
  bind_rows(rand_all1_meta %>%
              mutate(graph = "Random_all1",
                     Harmonic = harmonic_centrality(net_rand_all1),
                     Authority = authority_score(net_rand_all1)$vector,
                     PageRank = page_rank(net_rand_all1, directed = FALSE)$vector,
                     Triangles = sapply(1:n_nodes, FUN = count_triangles, graph = net_rand_all1),
                     Eigen_centrality = eigen_centrality(net_rand_all1, directed = FALSE)$vector,
                     Subgraph_centrality = subgraph_centrality(net_rand_all1, diag = FALSE))) %>%
  bind_rows(powerlaw_all1_meta %>%
              mutate(graph = "Powerlaw_all1",
                     Harmonic = harmonic_centrality(net_powerlaw_all1),
                     Authority = authority_score(net_powerlaw_all1)$vector,
                     PageRank = page_rank(net_powerlaw_all1, directed = FALSE)$vector,
                     Triangles = sapply(1:n_nodes, FUN = count_triangles, graph = net_powerlaw_all1),
                     Eigen_centrality = eigen_centrality(net_powerlaw_all1, directed = FALSE)$vector,
                     Subgraph_centrality = subgraph_centrality(net_powerlaw_all1, diag = FALSE))) -> net_avgloc_meta

net_avgloc_meta %>%
  group_by(graph) %>%
  mutate_at(vars(!any_of(c("node","graph","closeness_trasf"))), 
            scale_score) %>%
  mutate_at(vars(!any_of(c("node","graph","closeness_trasf"))), 
            \(x)(replace_na(x,0)))-> net_avgloc_meta_scaled

n_nodes <- 50
</script>
 
<script type="application/shiny-prerendered" data-context="server">
output$network <- renderVisNetwork({
    selected_fill <- meta_data2 %>%
      filter(network == input$net_degree) %>%
      pull(input$fill)
    selected_graph <- graph_exp_list[[input$net_degree]]
    
    color_palette <- col_numeric("viridis", domain = range(selected_fill))
    nodes <- data.frame(id = 1:n_nodes,
                        label = as.character(1:n_nodes),
                        color = color_palette(selected_fill))
    edges <- data.frame(from = selected_graph$E[,1],
                        to = selected_graph$E[,2],
                        color = 'black')
    visNetwork(nodes, edges) %>%
      visIgraphLayout(randomSeed = as.numeric(input$seed),
                      type = "full") %>%
      visNodes(#shape = "ellipse",
               font = list(color = 'black',
                           size = 50,
                           strokeWidth = 5,
                           strokeColor = "white"))
  })
output$sensitivity <- renderPlot({
  if(input$plot == 'Local influence'){
    res_data %>%
      filter(tau == input$tau,
             kappa == input$kappa,
             alpha == input$alpha,
             network == input$net_degree) %>%
      ggplot(aes(x = factor(node, levels = 1:n_nodes), 
                 y = value)) +
      geom_boxplot(aes(fill = !!sym(input$fill))) +
      scale_fill_viridis_c() +
      facet_grid(rows = vars(what), scale = 'free') +
      labs(x = 'Node') +
      theme(axis.title.y = element_blank()) -> plot_chosen
  } else {
    asym_data %>%
      filter(network == input$net_degree) %>%
      ggplot(aes(x = factor(node, levels = 1:n_nodes), 
                 y = value)) +
      geom_col(aes(fill = !!sym(input$fill))) +
      scale_fill_viridis_c() +
      facet_grid(rows = vars(what), scale = 'free') +
      labs(x = 'Node') +
      theme(axis.title.y = element_blank()) -> plot_chosen
  }
   plot_chosen 
  })
</script>
 
<script type="application/shiny-prerendered" data-context="server">
output$network_isocov <- renderVisNetwork({
    selected_fill <- meta_data2_isocov %>%
      filter(network == input$net_degree_isocov) %>%
      pull(input$fill)
    selected_graph <- graph_exp_list_isocov[[input$net_degree_isocov]]
    
    color_palette <- col_numeric("viridis", domain = range(selected_fill))
    nodes <- data.frame(id = 1:n_nodes,
                        label = as.character(1:n_nodes),
                        color = color_palette(selected_fill))
    edges <- data.frame(from = selected_graph$E[,1],
                        to = selected_graph$E[,2],
                        color = 'black')
    visNetwork(nodes, edges) %>%
      visIgraphLayout(randomSeed = as.numeric(input$seed_isocov),
                      type = "full") %>%
      visNodes(#shape = "ellipse",
               font = list(color = 'black',
                           size = 50,
                           strokeWidth = 5,
                           strokeColor = "white"))
  })
output$sensitivity_isocov <- renderPlot({
  if(input$plot == 'Local influence'){
    res_data_isocov %>%
      filter(sigma == input$sigma_isocov,
             kappa == input$kappa_isocov,
             network == input$net_degree_isocov) %>%
      ggplot(aes(x = factor(node, levels = 1:n_nodes), 
                 y = value)) +
      geom_boxplot(aes(fill = !!sym(input$fill_isocov))) +
      scale_fill_viridis_c() +
      facet_grid(rows = vars(what), scale = 'free') +
      labs(x = 'Node') +
      theme(axis.title.y = element_blank()) -> plot_chosen
  } else {
    asym_data_isocov %>%
      filter(network == input$net_degree_isocov) %>%
      ggplot(aes(x = factor(node, levels = 1:n_nodes), 
                 y = value)) +
      geom_col(aes(fill = !!sym(input$fill_isocov))) +
      scale_fill_viridis_c() +
      facet_grid(rows = vars(what), scale = 'free') +
      labs(x = 'Node') +
      theme(axis.title.y = element_blank()) -> plot_chosen
  }
   plot_chosen 
  })
output$sensitivity_isocov_teo <- renderPlot({
  res_data_isocov %>%
    group_by(node, sigma, kappa, what, network) %>%
    summarize(s2_est = var(value)) %>%
    full_join(loc_inf_teo_isocov, by = c("node", "sigma", "kappa", "what", "network")) %>%
    filter(sigma == input$sigma_isocov, 
           kappa == input$kappa_isocov,
           network == input$net_degree_isocov) %>%
    ggplot(aes(x = value, y = s2_est)) +
    geom_abline(slope = 1, intercept = 0) + 
    geom_point(aes(color = !!sym(input$fill_isocov)), alpha = 0.6) +
    scale_color_viridis_c() +
    facet_wrap(vars(what), scale = 'free') +
    labs(x = 'Theoretical (or approx) variance', y = 'Sample estimate of variance')
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
output$sensitivity_avgloc <- renderPlot({
  if(input$scale){
    res_avgloc_data %>%
      filter(model == input$model) %>%
      group_by(graph, node, h, model, parameter) %>%
      summarise(value = median(value)) %>%
      full_join(net_avgloc_meta_scaled , by = c('node', 'graph')) %>%
      ggplot(aes(x = h, y = value, group = node)) +
      geom_line(aes(color = !!sym(input$color)), alpha = 0.6) +
      scale_color_viridis_c() +
      facet_grid(rows = vars(parameter),
                 cols = vars(graph),
                 scale = 'free') -> plot_avgloc
  } else {
    res_avgloc_data %>%
      filter(model == input$model) %>%
      group_by(graph, node, h, model, parameter) %>%
      summarise(value = median(value)) %>%
      full_join(net_avgloc_meta, by = c('node', 'graph')) %>%
      ggplot(aes(x = h, y = value, group = node)) +
      geom_line(aes(color = !!sym(input$color)), alpha = 0.6) +
      scale_color_viridis_c() +
      facet_grid(rows = vars(parameter),
                 cols = vars(graph),
                 scale = 'free') -> plot_avgloc
  }
  plot_avgloc
})
</script>
 
<script type="application/shiny-prerendered" data-context="server-extras">
ojs_define <- function(..., .session = shiny::getDefaultReactiveDomain()) {
  quos <- rlang::enquos(...)
  vars <- rlang::list2(...)
  nm <- names(vars)
  if (is.null(nm)) {
    nm <- rep_len("", length(vars))
  }
  mapply(function(q, nm, val) {
    # Infer name, if possible
    if (nm == "") {
      tryCatch({
        nm <- rlang::as_name(q)
      }, error = function(e) {
        code <- paste(collapse = "\n", deparse(rlang::f_rhs(q)))
        stop("ojs_define() could not create a name for the argument: ", code)
      })
    }
    .session$output[[nm]] <- val
    outputOptions(.session$output, nm, suspendWhenHidden = FALSE)
    .session$sendCustomMessage("ojs-export", list(name = nm))
    NULL
  }, quos, nm, vars, SIMPLIFY = FALSE, USE.NAMES = FALSE)
  invisible()
}
</script>
</p>
<!--html_preserve-->
<script type="application/shiny-prerendered" data-context="dependencies">
{"type":"list","attributes":{},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["selectize"]},{"type":"character","attributes":{},"value":["0.12.4"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["www/shared/selectize"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/selectize.min.js","accessibility/js/selectize-plugin-a11y.min.js"]},{"type":"character","attributes":{},"value":["css/selectize.bootstrap3.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["shiny"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.7.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["selectize"]},{"type":"character","attributes":{},"value":["0.12.4"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["www/shared/selectize"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/selectize.min.js","accessibility/js/selectize-plugin-a11y.min.js"]},{"type":"character","attributes":{},"value":["css/selectize.bootstrap3.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["shiny"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.7.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["selectize"]},{"type":"character","attributes":{},"value":["0.12.4"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["www/shared/selectize"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/selectize.min.js","accessibility/js/selectize-plugin-a11y.min.js"]},{"type":"character","attributes":{},"value":["css/selectize.bootstrap3.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["shiny"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.7.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["selectize"]},{"type":"character","attributes":{},"value":["0.12.4"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["www/shared/selectize"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/selectize.min.js","accessibility/js/selectize-plugin-a11y.min.js"]},{"type":"character","attributes":{},"value":["css/selectize.bootstrap3.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["shiny"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.7.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["selectize"]},{"type":"character","attributes":{},"value":["0.12.4"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["www/shared/selectize"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/selectize.min.js","accessibility/js/selectize-plugin-a11y.min.js"]},{"type":"character","attributes":{},"value":["css/selectize.bootstrap3.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["shiny"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.7.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["selectize"]},{"type":"character","attributes":{},"value":["0.12.4"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["www/shared/selectize"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/selectize.min.js","accessibility/js/selectize-plugin-a11y.min.js"]},{"type":"character","attributes":{},"value":["css/selectize.bootstrap3.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["shiny"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.7.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["htmlwidgets"]},{"type":"character","attributes":{},"value":["1.6.2"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["www"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["htmlwidgets.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["htmlwidgets"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.6.2"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["vis"]},{"type":"character","attributes":{},"value":["9.1.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["htmlwidgets/lib/vis"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["vis-network.min.js"]},{"type":"character","attributes":{},"value":["vis-network.min.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["visNetwork"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.1.2"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["visNetwork-binding"]},{"type":"character","attributes":{},"value":["2.1.2"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["htmlwidgets"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["visNetwork.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["visNetwork"]},{"type":"logical","attributes":{},"value":[false]},{"type":"character","attributes":{},"value":["2.1.2"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["selectize"]},{"type":"character","attributes":{},"value":["0.12.4"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["www/shared/selectize"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/selectize.min.js","accessibility/js/selectize-plugin-a11y.min.js"]},{"type":"character","attributes":{},"value":["css/selectize.bootstrap3.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["shiny"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.7.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["selectize"]},{"type":"character","attributes":{},"value":["0.12.4"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["www/shared/selectize"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/selectize.min.js","accessibility/js/selectize-plugin-a11y.min.js"]},{"type":"character","attributes":{},"value":["css/selectize.bootstrap3.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["shiny"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.7.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["selectize"]},{"type":"character","attributes":{},"value":["0.12.4"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["www/shared/selectize"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/selectize.min.js","accessibility/js/selectize-plugin-a11y.min.js"]},{"type":"character","attributes":{},"value":["css/selectize.bootstrap3.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["shiny"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.7.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["selectize"]},{"type":"character","attributes":{},"value":["0.12.4"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["www/shared/selectize"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/selectize.min.js","accessibility/js/selectize-plugin-a11y.min.js"]},{"type":"character","attributes":{},"value":["css/selectize.bootstrap3.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["shiny"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.7.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["selectize"]},{"type":"character","attributes":{},"value":["0.12.4"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["www/shared/selectize"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/selectize.min.js","accessibility/js/selectize-plugin-a11y.min.js"]},{"type":"character","attributes":{},"value":["css/selectize.bootstrap3.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["shiny"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.7.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["htmlwidgets"]},{"type":"character","attributes":{},"value":["1.6.2"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["www"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["htmlwidgets.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["htmlwidgets"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.6.2"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["vis"]},{"type":"character","attributes":{},"value":["9.1.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["htmlwidgets/lib/vis"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["vis-network.min.js"]},{"type":"character","attributes":{},"value":["vis-network.min.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["visNetwork"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.1.2"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["visNetwork-binding"]},{"type":"character","attributes":{},"value":["2.1.2"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["htmlwidgets"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["visNetwork.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["visNetwork"]},{"type":"logical","attributes":{},"value":[false]},{"type":"character","attributes":{},"value":["2.1.2"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["selectize"]},{"type":"character","attributes":{},"value":["0.12.4"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["www/shared/selectize"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/selectize.min.js","accessibility/js/selectize-plugin-a11y.min.js"]},{"type":"character","attributes":{},"value":["css/selectize.bootstrap3.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["shiny"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.7.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["selectize"]},{"type":"character","attributes":{},"value":["0.12.4"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["www/shared/selectize"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/selectize.min.js","accessibility/js/selectize-plugin-a11y.min.js"]},{"type":"character","attributes":{},"value":["css/selectize.bootstrap3.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["shiny"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.7.5"]}]}]}
</script>
<!--/html_preserve-->
<!--html_preserve-->

<script type="application/shiny-prerendered" data-context="execution_dependencies">
{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["packages"]}},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["packages","version"]},"class":{"type":"character","attributes":{},"value":["data.frame"]},"row.names":{"type":"integer","attributes":{},"value":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78]}},"value":[{"type":"character","attributes":{},"value":["base","bslib","cachem","cli","colorspace","compiler","datasets","digest","dplyr","ellipsis","evaluate","fansi","fastmap","forcats","generics","ggplot2","glue","graphics","grDevices","grid","gridExtra","gtable","here","hms","htmltools","htmlwidgets","httpuv","igraph","jquerylib","jsonlite","knitr","later","lattice","lifecycle","lubridate","magrittr","Matrix","memoise","methods","MetricGraph","mime","munsell","pillar","pkgconfig","promises","purrr","R6","Rcpp","readr","rlang","rmarkdown","rprojroot","rSPDE","rstudioapi","sass","scales","shiny","sp","stats","stringi","stringr","tibble","tidyr","tidyselect","tidyverse","timechange","tools","tzdb","utf8","utils","vctrs","viridis","viridisLite","visNetwork","withr","xfun","xtable","yaml"]},{"type":"character","attributes":{},"value":["4.2.3","0.5.0","1.0.8","3.6.1","2.1-0","4.2.3","4.2.3","0.6.33","1.1.2","0.3.2","0.21","1.0.4","1.1.1","1.0.0","0.1.3","3.4.3","1.6.2","4.2.3","4.2.3","4.2.3","2.3","0.3.4","1.0.1","1.1.3","0.5.5","1.6.2","1.6.11","1.5.1","0.1.4","1.8.7","1.43","1.3.1","0.20-45","1.0.3","1.9.2","2.0.3","1.5-3","2.0.1","4.2.3","1.1.2.9000","0.12","0.5.0","1.9.0","2.0.3","1.2.0.1","1.0.1","2.5.1","1.0.11","2.1.4","1.1.1","2.23","2.0.3","2.3.2","0.15.0","0.4.7","1.2.1","1.7.5","2.0-0","4.2.3","1.7.12","1.5.0","3.2.1","1.3.0","1.2.0","2.0.0","0.2.0","4.2.3","0.4.0","1.2.3","4.2.3","0.6.3","0.6.4","0.4.2","2.1.2","2.5.1","0.39","1.8-4","2.3.7"]}]}]}
</script>
<!--/html_preserve-->
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>